---
title: "第一章第三节 语言评估标准"
excerpt: ""
exclude: true
sidebar:
  nav: "Books_CoPL_zhCN"
---
{% include toc icon="cog" title="本章目录" %}


# 1.3.1 可读性 Readability
在混沌时期(70年代以前)，写代码是开发项目的绝大部分，但是在上世纪七十年代，生命周期(Life cycle)被发明了出来以后，写代码之变成了项目的一部分，而维护和优化成为主要工作。所以可读性成为了评估一个语言的重要标准。

## 1.3.1.1 整体简洁度 Overall Simplicity 
拥有很多组件(Component)的语言比有较少的组件语言易学。很多人只是使用一个语言的一部分功能，当他们遇到新的功能语法的时候，就会懵逼。

另一个决定简洁的的问题是功能多样性(feature multiplicity)

>“你会写代码么？”我略略点一点头。他说，“会写代码，……我便考你一考。C语言的递增，怎样写的？”我想，讨饭一样的人，也配考我么？便回过脸去，不再理会。等了许久，“不能写罢？……我教给你，记着！这些语法应该记着。将来做码农的时候，写后端要用。”我暗想我比码农高到不知道哪里去了，而且我们后端也从用C语言写；又好笑，又不耐烦，懒懒的答他道，“谁要你教，不是 a = a + 1 ;么？” dalao显出极高兴的样子，将两个指头的长指甲敲着显示器，点头说，“对呀对呀！……C语言递增有四样写法，你知道么？

```
a = a + 1
a +=1
a++
++a
```

这里作者挖了个坑说第六章继续讲{: .notice--info}

第三个问题是操作符重载， 如果程序员A定义 数组 + 整数 等价于 数组的每个元素加这个整数。当别的程序员接手这段代码的时候可能会懵逼。

继续挖坑，第六章{: .notice--info}


## 1.3.1.2 正交性 Orthogonality
 
IBM 指令集 整数相加
```
A   Reg1,Memory_cell
AR  Reg1,Reg2
```
 
VAX 指令集 整数相加
```
ADDL operand_1, operand_2
```
operand 可以为寄存器或者内存单元。

VAX的设计具有正交性.
IMB的设计具有限制性所以难写.

正交性与语言复杂度紧密相关。

__语言的正交性越高，exception(例外?)越少。这也意味着规律性(regularity)越高，这个语言也就更加易学易懂。__

C语言的正交性较低（C++表示正交性是什么？）

但是过高的正交性也会产生问题，书中给的例子是ALGOL，但是我觉得Python这种动态类型语言，写大项目会很难受。

__正交性比简洁性重要，可牺牲简洁性来稳定正交性。__

__C++是非函数式语言,C是函数式语言__

因为人们认为函数式语言是正交性和简洁性的最佳结合，所以到现在还有很多人在废汉式语言中嵌函数式语言用。因为某些语言(C++)拥有更高的效率。

## 1.3.1.3 控制语句
滥用goto语句会导致语言可读性暴跌。上世纪70年代人们开始推崇结构式编程(Structured Programming)。

goto 在FORTRAN 77中被要求构造while循环。

用下面三种方式限制goto会稍微让代码可读一点。
- goto 语句必须优先于标签 （先声明？），除非是为了构造一个循环。
- 跳转不能太遥远。
- 他们的数字(标签？)必须被限制。
后来的高级语言通过设计更加高效的控制语句来达到接近废除goto。
因此可见控制语句的使用是代码可读性的一个重要影响因素。
## 1.3.1.4 数据类型和结构
足够的内置数据类型也会影响代码可读性。
比如一个语言没有布尔类型，True False用1和0代替。
那么
```
Found = 1
Found = true
```
第一种写法是影响代码阅读的。
另一个例子，如果不能结构体的话，定义一个复杂对象的数组需要写成定义N的数组，每个数组的元素只是对象的一部分信息。这样也会影响代码可读性。

## 1.3.1.5

未完待续{: .notice--primary}